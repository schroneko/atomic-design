'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ENQ_SEND = exports.ENQ_ASK = exports.CHANNEL_STOP = exports.CHANNEL_SLAVE = exports.CHANNEL_MASTER = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // eslint-disable-line


exports.default = initStore;
exports.getStoreCompose = getStoreCompose;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _immutable = require('immutable');

var _immutable2 = _interopRequireDefault(_immutable);

var _addons = require('@storybook/addons');

var _addons2 = _interopRequireDefault(_addons);

var _reactKomposer = require('react-komposer');

var _podda = require('podda');

var _podda2 = _interopRequireDefault(_podda);

var _api = require('./api');

var _api2 = _interopRequireDefault(_api);

var _ = require('../');

var _query = require('../utils/query');

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line
var loggerC = _logger.loggerOff; // note: debug
var loggerS = _logger.loggerOff; // note: debug
var loggerQ = _logger.loggerOff; // note: debug

var CHANNEL_MASTER = exports.CHANNEL_MASTER = 'MASTER';
var CHANNEL_SLAVE = exports.CHANNEL_SLAVE = 'SLAVE';
var CHANNEL_STOP = exports.CHANNEL_STOP = 'STOP';
var ENQ_ASK = exports.ENQ_ASK = 'ASK';
var ENQ_SEND = exports.ENQ_SEND = 'SEND';

var defaults = {
    uiTheme: { canvas: 'white', text: 'black' },
    label: 'init',
    index: 0
};

var storeDefaultSettings = {
    defaultData: defaults,
    addonApi: {},
    config: {
        EVENT_ID_INIT: _.EVENT_ID_INIT,
        EVENT_ID_DATA: _.EVENT_ID_DATA
    },
    queryParams: {
        //        label: 'init',
        //        index: 0,
    }
};

function initStore(storeSettings, storybookApi) {
    var config = _extends({}, storeDefaultSettings.config, storeSettings.config);

    var addonApi = _extends({}, storeDefaultSettings.addonApi, storeSettings.addonApi);

    var defaultData = storeSettings.defaultData || storeDefaultSettings.defaultData;
    var queryParams = storeSettings.queryParams || storeDefaultSettings.queryParams;

    var queryInitData = null;
    var addonStore = new _podda2.default(defaultData);
    loggerS.warn('*** new Store init ***');
    //    loggerS.log('storeSettings', storeSettings);
    //    loggerS.log('storeDefaultSettings', storeDefaultSettings);

    addonStore.registerAPI('bypass', function (store, data, bypassList) {
        var fullCallbackList = store.callbacks;
        // eslint-disable-next-line
        store.callbacks = store.callbacks.filter(function (val) {
            return !(bypassList || []).includes(val);
        });
        store.update(function () {
            return _extends({}, data);
        });
        // eslint-disable-next-line
        store.callbacks = fullCallbackList;
    });

    addonStore.registerAPI('reset', function (store) {
        loggerS.info('Store reset');
        // eslint-disable-next-line
        store.data = _immutable2.default.Map(defaultData);
        store.fireSubscriptions();
    });

    function createApi(poddaStore, apilist) {
        var keys = Object.keys(apilist);

        var apiMap = {};
        keys.forEach(function (val) {
            apiMap[val] = function () {
                for (var _len = arguments.length, props = Array(_len), _key = 0; _key < _len; _key++) {
                    props[_key] = arguments[_key];
                }

                return function () {
                    try {
                        return apilist[val].apply(apilist, [poddaStore].concat(props));
                    } catch (err) {
                        _logger2.default.groupCollapsed(err.name + ' in ' + val + ' API: ' + err.message);
                        _logger2.default.log('store settings:', storeSettings);
                        _logger2.default.log('store data:', addonStore.getAll());
                        _logger2.default.log(err);
                        _logger2.default.groupEnd(err.name + ' in ' + val + ' API: ' + err.message);
                        return null;
                    }
                };
            };
        });
        return apiMap;
    }

    /** note: setup channel
     *
     *  Need to init channel connection between panel side and stories side
     *
     *  setupChannel(initCb) = channelInit(storeEnquiry, id)
     *  , where:
     *  id - channel identifier
     *  storeEnquiry = ENQ_ASK to ask data after init
     *  storeEnquiry = ENQ_SEND to send data after init
     *  setupChannel - need to invoke in componentWillMount (see below)
     *
     */
    function channelInit(storeEnquiry, id, onInit) {
        loggerC.info('channelInit storeEnquiry:', storeEnquiry, id);
        var channel = void 0;
        var channelRole = CHANNEL_STOP;
        var channelId = id;
        var peerId = null;
        var initCallback = null;

        var watchQuery = function watchQuery(queryData) {
            loggerQ.log('queryData (id:' + channelId + '):', queryData);
            // todo: here add api for query manage (queryData => addonStore)
            (0, _query.querySet)(queryData, storybookApi);
            queryInitData = queryData;
        };

        var onStoreChange = function onStoreChange(dataStore) {
            loggerS.log('Store Changed in ' + channelRole, dataStore);
            if (channelRole === CHANNEL_STOP) return;
            channel.emit(config.EVENT_ID_DATA, {
                dataStore: dataStore,
                role: channelRole,
                id: channelId,
                to: peerId
            });
        };

        var onDataChannel = function onDataChannel(dataChannel) {
            loggerC.log('onDataChannel (I\'m ' + channelRole + ' id:' + channelId + '):', 'from: ' + dataChannel.id + ' to: ' + dataChannel.to + ' myPeer: ' + peerId);
            if (channelRole === CHANNEL_STOP) return;
            if (dataChannel.to === channelId && dataChannel.id === peerId) {
                if (dataChannel.dataStore.queryData) {
                    watchQuery(dataChannel.dataStore.queryData);
                }
                addonStore.bypass(dataChannel.dataStore, [onStoreChange]);
            }
        };

        var startChannel = function startChannel() {
            channel.emit(config.EVENT_ID_INIT, {
                info: 'wonna be a master',
                role: CHANNEL_MASTER,
                id: channelId,
                to: 'any',
                query: queryInitData
            });
        };

        var stopChannel = function stopChannel() {
            channelRole = CHANNEL_STOP;
            channel.emit(config.EVENT_ID_INIT, {
                info: 'stop channel connection',
                role: channelRole,
                id: channelId
            });
            if (storeEnquiry === ENQ_ASK) {
                addonStore.reset();
            }
            /* channel.emit(config.EVENT_ID_DATA, { // fixme:
                dataStore: {},
                role: channelRole,
                id: channelId,
                to: peerId,
            });*/
        };

        var setChannelMaster = function setChannelMaster(initData) {
            if (initData.to !== channelId) {
                channelRole = CHANNEL_STOP;
                peerId = null;
                loggerC.log('onInitChannel: I\'m a ' + channelRole + ' now, id=' + channelId + ' peerId=' + peerId);
                return;
            }
            peerId = initData.id;
            channelRole = CHANNEL_MASTER;
            loggerC.log('onInitChannel: I\'m a ' + channelRole + ' now, id=' + channelId + ' peerId=' + peerId);
        };

        var setChannelSlave = function setChannelSlave(initData) {
            peerId = initData.id;
            channelRole = CHANNEL_SLAVE;
            queryInitData = queryInitData || (0, _query.queryFetch)(queryParams, storybookApi);
            channel.emit(config.EVENT_ID_INIT, {
                info: 'so I\'m a slave',
                role: channelRole,
                id: channelId,
                to: peerId,
                query: queryInitData
            });
            loggerC.log('onInitChannel: I\'m a ' + channelRole + ' now, id=' + channelId + ' peerId=' + peerId);
        };

        var storeQueryData = function storeQueryData(queryData) {
            var data = { queryData: queryData };
            if (addonApi.$queryFetch) {
                data = addonApi.$queryFetch(addonStore, queryData);
            }
            watchQuery(queryData);
            addonStore.bypass(data, [onStoreChange]);
        };

        var onInitChannel = function onInitChannel(initData) {
            loggerC.log('onInitChannel', initData);

            if (initData.role === CHANNEL_MASTER) {
                setChannelSlave(initData);
            }

            if (initData.role === CHANNEL_SLAVE) {
                setChannelMaster(initData);
            }

            //            if (initData.queryInit) {
            //                queryInitData;
            //            }

            if (initData.role === CHANNEL_STOP) {
                loggerC.log('Stop Channel: I was a ' + channelRole + ', id=' + channelId);
                channelRole = CHANNEL_STOP;
                if (storeEnquiry === ENQ_ASK) {
                    // addonStore.reset();
                }
            } else {
                loggerC.log('storeEnquiry:', storeEnquiry);
                if (initData.query && !queryInitData) storeQueryData(initData.query);
                if (storeEnquiry === ENQ_SEND) {
                    onStoreChange(addonStore.getAll());
                }
            }

            if (initCallback) {
                initCallback({ channelRole: channelRole, storeEnquiry: storeEnquiry, channelId: channelId, peerId: peerId });
            }
        };

        if (typeof onInit === 'function') {
            onInit(addonStore, storybookApi);
        }

        /**
          * note: this callback should be invoked
          * in componentWillMount() to init channel connection
          * and the returned callback could be invoked
          * in componentWillUnmount().
          * initCb() - will be invoked after getting connected
          *
          */
        return function setupChannel(initCb) {
            initCallback = initCb;
            channel = _addons2.default.getChannel();
            var stopStorySubscription = void 0;

            var stopQuerySubscription = addonStore.watch('queryData', watchQuery);

            loggerC.info('setupChannel:');

            try {
                queryInitData = (0, _query.queryFetch)(queryParams, storybookApi) || queryInitData;
                if (queryInitData) {
                    loggerQ.log('queryFetch:', queryInitData);
                    storeQueryData(queryInitData);
                }

                channel.on(config.EVENT_ID_INIT, onInitChannel);
                startChannel(queryInitData);

                stopStorySubscription = addonStore.subscribe(onStoreChange);

                channel.on(config.EVENT_ID_DATA, onDataChannel);
            } catch (err) {
                loggerC.warn(err);
            }

            return function () {
                loggerC.info('Channel STOPS');
                stopChannel();
                channel.removeListener(config.EVENT_ID_INIT, onInitChannel);
                channel.removeListener(config.EVENT_ID_DATA, onDataChannel);
                stopQuerySubscription();
                stopStorySubscription();
            };
        };
    }

    // changes: refactoring. addonStoreCompose goes to composer.js

    /*
        const addonStoreCompose = setDefaults({
        //    pure: true,
            propsToWatch: [],
            loadingHandler: () => (<p>Loading...</p>),
            env: {
                addonStore,
                apiMap: createApi(addonStore, { ...apiLib, ...addonApi }),
                channelInit,
                storybookApi,
            },
        });
            return addonStoreCompose;
    */

    var env = {
        addonStore: addonStore,
        apiMap: createApi(addonStore, _extends({}, _api2.default, addonApi)),
        channelInit: channelInit,
        storybookApi: storybookApi
    };
    loggerS.log('Store created:', addonStore.getAll());
    return env;
}

var defaultHandler = function defaultHandler() {
    return _react2.default.createElement(
        'p',
        null,
        'Loading...'
    );
};

function getStoreCompose(environment) {
    var loadingHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultHandler;
    var propsToWatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    return (0, _reactKomposer.setDefaults)({
        // pure: true,
        propsToWatch: propsToWatch,
        loadingHandler: loadingHandler,
        env: environment
    });
}